#include <stdio.h> #include <stdlib.h> #include <stdbool.h>
#include <limits.h> #include<sys/time.h>


#define MAX +1
#define MIN -1
#define INFINI INT_MAX

#define KGRN "\x1B[32m" #define KRED "\x1B[31m" #define KWHT "\x1B[37m"


struct config {
char mat[8][8]; int val;
char xrN, yrN, xrB, yrB; char roqueN, roqueB;

};


int PawnIsolated = -30; int PawnDouble = -30; int RookOpenFile = 70;
int RookSemiOpenFile = 50;


int QueenOpenFile = 50;

int QueenSemiOpenFile = 30; int BishopPair = 50;
int PawnTable[64] = {
0	,	0	,  0	,  0	,  0	,	0	,	0	,	0
,

,
0	,	0	,	0	,	0	,	0	,	0	,
0	,	0
};

int RookTable[64] = {

0
,

0

,
25

,
50
,
50
,
25
,
0




,
0

,













0


,
0

,
25
,
50
,
50
,
25

,


0


,
0
,












0


,
0

,
25
,
50
,
50
,
25

,


0


,
0

,











0


,
0

,
25
,
50
,
50
,
25
,



0


,
0
,












0


,
0

,
25
,
50
,
50
,
25

,


0


,
0

,











0


,
0

,
25
,
50
,
50
,
25

,


0


,
0

,











90


,
90

,
90
,
90
,
90
,
90

,


90


,
90

,











0


,
0

,
25
,
50
,
50
,
25

,


0


,
0











};



















int KingE[64] = {
,

,









,
,


};


int KingO[64] = {

0
,
25

,
25

,
-50
,
-50
,
0
,
50
,
25
,












-300
,
-300
,

-300
,

-300

,
-300
,
-300
,
-300
,
-300
,











-500
,
-500
,

-500
,

-500

,
-500
,
-500
,
-500
,
-500
,












-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700
,









-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700
,









-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700
,









-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700
,









-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700









};














int dC[8][2] = { {-2,+1} , {-1,+2} , {+1,+2} , {+2,+1} , {+2,-1} , {+1,-2} , {-1,-2} , {-2,-1} };

int D[8][2] = { {+1,0} , {+1,+1} , {0,+1} , {-1,+1} , {-1,0} , {-1,-1} , {0,-1} , {+1,-1} };


int minmax_ab( struct config conf, int mode, int niv, int min, int max, long * nb_noeuds, long * nb_coupes);



void copier( struct config *c1, struct config *c2 )
{
int i, j;

for (i=0; i<8; i++)
for (j=0; j<8; j++)
c2->mat[i][j] = c1->mat[i][j];

c2->val = c1->val; c2->xrB = c1->xrB; c2->yrB = c1->yrB; c2->xrN = c1->xrN; c2->yrN = c1->yrN;

c2->roqueB = c1->roqueB; c2->roqueN = c1->roqueN;
}



int egal(char c1[8][8], char c2[8][8] )
{
int i, j;

for (i=0; i<8; i++)
for (j=0; j<8; j++)
if (c1[i][j] != c2[i][j]) return 0;
return 1;

} // egal

int nbrPieces(struct config board, bool type) /// Compter le nombre des piÃ©ces
{
int i, j, nbr = 0; if(type)
{
for(i = 0 ; i <= 7 ; i++)
{
for(j = 0 ; j <= 7 ; j++)
{
if(board.mat[i][j] > 0)
{
nbr ++;
}
}
}
}
else
{
for(i = 0 ; i <= 7 ; i++)
{
for(j = 0 ; j <= 7 ; j++)
{
if(board.mat[i][j] < 0)
{
nbr ++;
}
}
}
}
return nbr;
}


int estim(struct config board) /// La fonction d'evaluation de la configuration
{
int i, j;
int matrice = 0;
int isole = 0, rowB, rowN, nbrPionB = 0, nbrPionN = 0, doubl = 0; bool pionPosB_1 = false, pionPosB_2 = false, pionPosB = false; bool pionPosN_1 = false, pionPosN_2 = false, pionPosN = false; int k, rockB_nbrOpen = 0, rockN_nbrOpen = 0, rockValue = 0;
int queenN_nbrOpen = 0, queenB_nbrOpen = 0, queenValue = 0; int nbrBishopB = 0, nbrBishopN = 0, bishopValue = 0;
int resultat, materiel=0; for(j = 0 ; j <= 7 ; j++)
{
for(i = 0 ; i <= 7 ; i++)
{
switch(board.mat[i][j])
{
case 'p':
materiel += 100;
matrice += PawnTable[j + i * 8]; nbrPionB ++;
pionPosB = true; if(!pionPosB_1)
{
if(!pionPosB_2)
{
pionPosB_2 = true; rowB = j;
}
else
{
if (rowB != j)
{
pionPosB_1 = true;
}
}
}
break; case -'p':
materiel -= 100;
matrice -= PawnTable[j + (7 - i) * 8]; nbrPionN ++;
pionPosN = true; if(!pionPosN_1)
{
if(!pionPosN_2)
{
pionPosN_2 = true; rowN = j;
}
else
{
if (rowN != j)
{
pionPosN_1 = true;
}
}
}
break; case 'C':
materiel += 300;

matrice += KnightTable[j + i * 8];
break; case -'C':
materiel -= 300;

matrice -= KnightTable[j + (7 - i) * 8]; break;
case 'f':
materiel += 325;
matrice += BishopTable[j + i * 8]; nbrBishopB ++;
break; case -'f':
materiel -= 325;
matrice -= BishopTable[j + (7 - i) * 8]; nbrBishopN ++;
break; case 't':
materiel += 500;
matrice += RookTable[j + i * 8]; k = 0;
while((k <= 7) && (board.mat[k][j] != 'p'))
{
if(((board.mat[k][j] == 0) || (board.mat[k][j] == 't')) || (board.mat[k][j] < 0))
{
rockB_nbrOpen ++;
}
k++;
}
break; case -'t':
materiel -= 500;
matrice -= RookTable[j + (7 - i) * 8]; k = 7;
while((k >= 0) && (board.mat[k][j] != -'p'))
{
if(((board.mat[k][j] == 0) || (board.mat[k][j] == -'t')) || (board.mat[k][j] < 0))
{
rockN_nbrOpen ++;
}
k --;
}
break; case 'n':
materiel += 1000;
k = 0;
while((k <= 7) && (board.mat[k][j] != 'p'))
{
if(((board.mat[k][j] == 0) || (board.mat[k][j] == 'n')) || (board.mat[k][j] < 0))
{
queenB_nbrOpen ++;
}
k++;
}
break; case -'n':
materiel -= 1000;
k = 7;
while((k >= 0) && (board.mat[k][j] != -'p'))
{
if(((board.mat[k][j] == 0) || (board.mat[k][j] == -'n')) || (board.mat[k][j] < 0))
{
queenN_nbrOpen ++;
}
k --;
}
break; case 'r':
if(nbrPieces(board, true) > 8)
{
matrice += KingO[j + i * 8];
}
if(nbrPieces(board, true) < 7)
{
matrice += KingE[j + i * 8];
}
break; case -'r':
if(nbrPieces(board, true) > 8)
{
matrice -= KingO[j + (7 - i) * 8];
}
if(nbrPieces(board, true) < 7)
{
matrice -= KingE[j + (7 - i) * 8];
}
break;
}
}

if(nbrPionB > 0)
{
doubl = doubl + nbrPionB - 1;
}
if(nbrPionN > 0)
{
doubl = doubl + nbrPionN - 1;
}
nbrPionB = 0;
nbrPionN = 0;

if(!pionPosB && !pionPosB_1 && pionPosB_2)
{
isole ++;
}
if(!pionPosB)
{
pionPosB_1 = false; pionPosB_2 = false;
}
pionPosB = false;

nbrPionN = 0;
if(!pionPosN && !pionPosN_1 && pionPosN_2)
{
isole --;
}
if(!pionPosN)
{
pionPosN_1 = false; pionPosN_2 = false;
}
pionPosN = false;

if(rockB_nbrOpen == 8)
{
rockValue += RookOpenFile;
}
else
{
if(rockB_nbrOpen > 5)
{
rockValue += RookSemiOpenFile;
}
}
if(rockN_nbrOpen == 8)
{
rockValue -= RookOpenFile;
}
else
{
if(rockN_nbrOpen > 5)
{
rockValue -= RookSemiOpenFile;
}
}
rockB_nbrOpen = 0;
rockN_nbrOpen = 0;

if(queenB_nbrOpen == 8)
{
queenValue += QueenOpenFile;
}
else
{
if(queenB_nbrOpen > 5)
{
queenValue += QueenSemiOpenFile;
}
}
if(queenN_nbrOpen == 8)
{
queenValue -= QueenOpenFile;
}
else
{
if(queenN_nbrOpen > 5)
{
queenValue -= QueenSemiOpenFile;
}
}
queenB_nbrOpen = 0;
queenN_nbrOpen = 0;

if(nbrBishopB == 2)
{
bishopValue += BishopPair; nbrBishopB = 0;
}
if(nbrBishopN == 2)
{
bishopValue -= BishopPair; nbrBishopN = 0;
}
}
resultat = materiel + doubl * PawnDouble + isole * PawnIsolated + rockValue + queenValue + bishopValue + matrice;

return resultat;
}
// estim

/***********************************************************/
/*********** Partie: Evaluations et Estimations ***********/
/***********************************************************/
/* Teste s'il n'y a aucun coup possible dans la configuration conf */ int AucunCoupPossible( struct config conf )
{
// ... A completer pour les matchs nuls
// ... vÃ©rifier que generer_succ retourne 0 configurations filles ... return 0;

} // AucunCoupPossible


/* Teste si conf reprÃ©sente une fin de partie et retourne dans 'cout' la valeur associÃ©e */ int feuille( struct config conf, int *cout )
{
//int i, j, rbx, rnx, rby, rny;

*cout = 0;

// Si victoire pour les Noirs cout = -100 if ( conf.xrB == -1 ) {
*cout = -100;
return 1;
}

// Si victoire pour les Blancs cout = +100 if ( conf.xrN == -1 ) {
*cout = +100;
return 1;
}

// Si Match nul cout = 0
if ( conf.xrB != -1 && conf.xrN != -1 && AucunCoupPossible( conf ) ) return 1;

// Sinon ce n'est pas une config feuille return 0;

} // feuille



/***********************************************************/
/*********** Partie: GÃ©nÃ©ration des Successeurs ***********/
/***********************************************************/


/* GÃ©nÃ¨re dans T les configurations obtenues Ã partir de conf lorsqu'un pion atteint la limite de l'Ã©chiq */
void transformPion( struct config conf, int a, int b, int x, int y, struct config T[], int *n )
{
int signe = +1;
if (conf.mat[a][b] < 0 ) signe = -1;
copier(&conf, &T[*n]); T[*n].mat[a][b] = 0;
T[*n].mat[x][y] = signe *'n'; (*n)++;
copier(&conf, &T[*n]); T[*n].mat[a][b] = 0;
T[*n].mat[x][y] = signe *'c'; (*n)++;
copier(&conf, &T[*n]); T[*n].mat[a][b] = 0;
T[*n].mat[x][y] = signe *'f'; (*n)++;
copier(&conf, &T[*n]); T[*n].mat[a][b] = 0;
T[*n].mat[x][y] = signe *'t'; (*n)++;

} // transformPion


// VÃ©rifie si la case (x,y) est menacÃ©e par une des piÃ¨ces du joueur 'mode' int caseMenaceePar( int mode, int x, int y, struct config conf )
{
int i, j, a, b, stop;

// menace par le roi ... for (i=0; i<8; i += 1) {
// traitement des 8 directions paires et impaires a = x + D[i][0];
b = y + D[i][1];
if ( a >= 0 && a <= 7 && b >= 0 && b <= 7 )
if ( conf.mat[a][b]*mode == 'r' ) return 1;
} // for

// menace par cavalier ... for (i=0; i<8; i++)
if ( x+dC[i][0] <= 7 && x+dC[i][0] >= 0 && y+dC[i][1] <= 7 && y+dC[i][1] >= 0 ) if ( conf.mat[ x+dC[i][0] ] [ y+dC[i][1] ] * mode == 'c' )
return 1;

// menace par pion ...
if ( (x-mode) >= 0 && (x-mode) <= 7 && y > 0 && conf.mat[x-mode][y-1]*mode == 'p' ) return 1;
if ( (x-mode) >= 0 && (x-mode) <= 7 && y < 7 && conf.mat[x-mode][y+1]*mode == 'p' ) return 1;

// menace par fou, tour ou reine ... for (i=0; i<8; i += 1) {
// traitement des 8 directions paires et impaires stop = 0;
a = x + D[i][0];
b = y + D[i][1];
while ( !stop && a >= 0 && a <= 7 && b >= 0 && b <= 7 ) if ( conf.mat[a][b] != 0 ) stop = 1;
else {
a = a + D[i][0];
b = b + D[i][1];
}
if ( stop ) {
if ( conf.mat[a][b]*mode == 'f' && i % 2 != 0 ) return 1; if ( conf.mat[a][b]*mode == 't' && i % 2 == 0 ) return 1; if ( conf.mat[a][b]*mode == 'n' ) return 1;
}
} // for

// sinon, aucune menace ... return 0;

} // caseMenaceePar


/* GÃ©nere dans T tous les coups possibles de la piÃ¨ce (de couleur N) se trouvant Ã la pos x,y */ void deplacementsN(struct config conf, int x, int y, struct config T[], int *n )
{
int i, j, a, b, stop;






case
switch(conf.mat[x][y]) {
// mvmt PION ... case -'p' :
//***printf("PION N Ã la pos (%d,%d) \n", x,y);
if ( x > 0 && conf.mat[x-1][y] == 0 ) {	// avance d'une

copier(&conf, &T[*n]); T[*n].mat[x][y] = 0; T[*n].mat[x-1][y] = -'p'; (*n)++;
if ( x == 1 ) transformPion( conf, x, y, x-1, y, T, n );
}
if ( x == 6 && conf.mat[5][y] == 0 && conf.mat[4][y] == 0) {	// avance de 2 cases copier(&conf, &T[*n]);
T[*n].mat[6][y] = 0;
T[*n].mat[4][y] = -'p'; (*n)++;


descendant)
}
if ( x > 0 && y >0 && conf.mat[x-1][y-1] > 0 ) {	// mange Ã droite (en

copier(&conf, &T[*n]); T[*n].mat[x][y] = 0; T[*n].mat[x-1][y-1] = -'p';
// cas oÃ¹ le roi adverse est pris...
if (T[*n].xrB == x-1 && T[*n].yrB == y-1) {
T[*n].xrB = -1; T[*n].yrB = -1;
}

(*n)++;
if ( x == 1 ) transformPion( conf, x, y, x-1, y-1, T, n );
}

descendant)
if ( x > 0 && y < 7 && conf.mat[x-1][y+1] > 0 ) {	// mange Ã gauche (en

copier(&conf, &T[*n]); T[*n].mat[x][y] = 0; T[*n].mat[x-1][y+1] = -'p';
// cas oÃ¹ le roi adverse est pris...
if (T[*n].xrB == x-1 && T[*n].yrB == y+1) { T[*n].xrB = -1; T[*n].yrB = -1;
}

(*n)++;
if ( x == 1 ) transformPion( conf, x, y, x-1, y+1, T, n );
}
break;

// mvmt CAVALIER ... case -'c' :
for (i=0; i<8; i++)
if ( x+dC[i][0] <= 7 && x+dC[i][0] >= 0 && y+dC[i][1] <= 7 && y+dC[i][1] >= 0 ) if ( conf.mat[ x+dC[i][0] ] [ y+dC[i][1] ] >= 0 ) {
copier(&conf, &T[*n]); T[*n].mat[x][y] = 0;
T[*n].mat[ x+dC[i][0] ][ y+dC[i][1] ] = -'c';
// cas oÃ¹ le roi adverse est pris...
if (T[*n].xrB == x+dC[i][0] && T[*n].yrB == y+dC[i][1]) { T[*n].xrB = -1; T[*n].yrB = -1;
}

(*n)++;
}
break;

// mvmt FOU ... case -'f' :
for (i=1; i<8; i += 2) {
// traitement des directions impaires (1, 3, 5 et 7)
stop = 0;
a = x + D[i][0];
b = y + D[i][1];
while ( !stop && a >= 0 && a <= 7 && b >= 0 && b <= 7 ) { if ( conf.mat[ a ] [ b ] < 0 ) stop = 1;
else {
copier(&conf, &T[*n]); T[*n].mat[x][y] = 0;
if ( T[*n].mat[a][b] > 0 ) stop = 1;
T[*n].mat[a][b] = -'f';
// cas oÃ¹ le roi adverse est pris...
if (T[*n].xrB == a && T[*n].yrB == b) { T[*n].xrB = -1; T[*n].yrB = -1; }

(*n)++;
a = a + D[i][0];
b = b + D[i][1];
}
} // while
} // for break;

// mvmt TOUR ... case -'t' :
for (i=0; i<8; i += 2) {
// traitement des directions paires (0, 2, 4 et 6)
stop = 0;
a = x + D[i][0];
b = y + D[i][1];
while ( !stop && a >= 0 && a <= 7 && b >= 0 && b <= 7 ) { if ( conf.mat[ a ] [ b ] < 0 ) stop = 1;
else {
copier(&conf, &T[*n]); T[*n].mat[x][y] = 0;
if ( T[*n].mat[a][b] > 0 ) stop = 1;
T[*n].mat[a][b] = -'t';
// cas oÃ¹ le roi adverse est pris...
if (T[*n].xrB == a && T[*n].yrB == b) { T[*n].xrB = -1; T[*n].yrB = -1; }






possibles




possibles
if ( conf.roqueN != 'e' && conf.roqueN != 'n' ) { if ( x == 7 && y == 0 && conf.roqueN != 'p')
T[*n].roqueN = 'g'; // le grand roque ne sera plus possible else if ( x == 7 && y == 0 )
T[*n].roqueN = 'n'; // ni le grand roque ni le petit roque ne seront

if ( x == 7 && y == 7 && conf.roqueN != 'g' )
T[*n].roqueN = 'p'; // le petit roque ne sera plus possible else if ( x == 7 && y == 7 )
T[*n].roqueN = 'n'; // ni le grand roque ni le petit roque ne seront
}

(*n)++;
a = a + D[i][0];
b = b + D[i][1];
}
} // while
} // for break;

// mvmt REINE ... case -'n' :
for (i=0; i<8; i += 1) {
// traitement des 8 directions paires et impaires stop = 0;
a = x + D[i][0];
b = y + D[i][1];
while ( !stop && a >= 0 && a <= 7 && b >= 0 && b <= 7 ) { if ( conf.mat[ a ] [ b ] < 0 ) stop = 1;
else {
copier(&conf, &T[*n]); T[*n].mat[x][y] = 0;
if ( T[*n].mat[a][b] > 0 ) stop = 1;
T[*n].mat[a][b] = -'n';
// cas oÃ¹ le roi adverse est pris...
if (T[*n].xrB == a && T[*n].yrB == b) { T[*n].xrB = -1; T[*n].yrB = -1; }

(*n)++;
a = a + D[i][0];
b = b + D[i][1];
}
} // while
} // for break;

// mvmt ROI ... case -'r' :
// vÃ©rifier possibilitÃ© de faire un roque ... if ( conf.roqueN != 'n' && conf.roqueN != 'e' ) {
if ( conf.roqueN != 'g' && conf.mat[7][1] == 0 && conf.mat[7][2] == 0 && conf.mat[7][3] == 0 )
if ( !caseMenaceePar( MAX, 7, 1, conf ) && !caseMenaceePar( MAX, 7, 2, conf )
&& \ conf ) ) {
config
!caseMenaceePar( MAX, 7, 3, conf ) && !caseMenaceePar( MAX, 7, 4,
// Faire un grand roque ... copier(&conf, &T[*n]); T[*n].mat[7][4] = 0;
T[*n].mat[7][0] = 0;
T[*n].mat[7][2] = -'r'; T[*n].xrN = 7; T[*n].yrN = 2; T[*n].mat[7][3] = -'t';
T[*n].roqueN = 'e'; // aucun roque ne sera plus possible Ã partir de cette

(*n)++;
}

&& \
if ( conf.roqueN != 'p' && conf.mat[7][5] == 0 && conf.mat[7][6] == 0 )
if ( !caseMenaceePar( MAX, 7, 4, conf ) && !caseMenaceePar( MAX, 7, 5, conf )

!caseMenaceePar( MAX, 7, 6, conf ) ) {
// Faire un petit roque ... copier(&conf, &T[*n]); T[*n].mat[7][4] = 0;
T[*n].mat[7][7] = 0;
