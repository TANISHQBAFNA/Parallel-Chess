#include <stdio.h> #include <stdlib.h> #include <stdbool.h>
#include <limits.h> #include<sys/time.h>


#define MAX +1
#define MIN -1
#define INFINI INT_MAX

#define KGRN "\x1B[32m" #define KRED "\x1B[31m" #define KWHT "\x1B[37m"


struct config {
char mat[8][8]; int val;
char xrN, yrN, xrB, yrB; char roqueN, roqueB;

};


int PawnIsolated = -30; int PawnDouble = -30; int RookOpenFile = 70;
int RookSemiOpenFile = 50;


int QueenOpenFile = 50;

int QueenSemiOpenFile = 30; int BishopPair = 50;
int PawnTable[64] = {
0	,	0	,  0	,  0	,  0	,	0	,	0	,	0
,

,
0	,	0	,	0	,	0	,	0	,	0	,
0	,	0
};

int RookTable[64] = {

0
,

0

,
25

,
50
,
50
,
25
,
0




,
0

,













0


,
0

,
25
,
50
,
50
,
25

,


0


,
0
,












0


,
0

,
25
,
50
,
50
,
25

,


0


,
0

,











0


,
0

,
25
,
50
,
50
,
25
,



0


,
0
,












0


,
0

,
25
,
50
,
50
,
25

,


0


,
0

,











0


,
0

,
25
,
50
,
50
,
25

,


0


,
0

,











90


,
90

,
90
,
90
,
90
,
90

,


90


,
90

,











0


,
0

,
25
,
50
,
50
,
25

,


0


,
0











};



















int KingE[64] = {
,

,









,
,


};


int KingO[64] = {

0
,
25

,
25

,
-50
,
-50
,
0
,
50
,
25
,












-300
,
-300
,

-300
,

-300

,
-300
,
-300
,
-300
,
-300
,











-500
,
-500
,

-500
,

-500

,
-500
,
-500
,
-500
,
-500
,












-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700
,









-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700
,









-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700
,









-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700
,









-700
,
-700
,
-700
,
-700
,
-700
,
-700
,

-700
,
-700









};














int dC[8][2] = { {-2,+1} , {-1,+2} , {+1,+2} , {+2,+1} , {+2,-1} , {+1,-2} , {-1,-2} , {-2,-1} };

int D[8][2] = { {+1,0} , {+1,+1} , {0,+1} , {-1,+1} , {-1,0} , {-1,-1} , {0,-1} , {+1,-1} };


int minmax_ab( struct config conf, int mode, int niv, int min, int max, long * nb_noeuds, long * nb_coupes);



void copier( struct config *c1, struct config *c2 )
{
int i, j;

for (i=0; i<8; i++)
for (j=0; j<8; j++)
c2->mat[i][j] = c1->mat[i][j];

c2->val = c1->val; c2->xrB = c1->xrB; c2->yrB = c1->yrB; c2->xrN = c1->xrN; c2->yrN = c1->yrN;

c2->roqueB = c1->roqueB; c2->roqueN = c1->roqueN;
}



int egal(char c1[8][8], char c2[8][8] )
{
int i, j;

for (i=0; i<8; i++)
for (j=0; j<8; j++)
if (c1[i][j] != c2[i][j]) return 0;
return 1;

} // egal

int nbrPieces(struct config board, bool type) /// Compter le nombre des piÃ©ces
{
int i, j, nbr = 0; if(type)
{
for(i = 0 ; i <= 7 ; i++)
{
for(j = 0 ; j <= 7 ; j++)
{
if(board.mat[i][j] > 0)
{
nbr ++;
}
}
}
}
else
{
for(i = 0 ; i <= 7 ; i++)
{
for(j = 0 ; j <= 7 ; j++)
{
if(board.mat[i][j] < 0)
{
nbr ++;
}
}
}
}
return nbr;
}


int estim(struct config board) /// La fonction d'evaluation de la configuration
{
int i, j;
int matrice = 0;
int isole = 0, rowB, rowN, nbrPionB = 0, nbrPionN = 0, doubl = 0; bool pionPosB_1 = false, pionPosB_2 = false, pionPosB = false; bool pionPosN_1 = false, pionPosN_2 = false, pionPosN = false; int k, rockB_nbrOpen = 0, rockN_nbrOpen = 0, rockValue = 0;
int queenN_nbrOpen = 0, queenB_nbrOpen = 0, queenValue = 0; int nbrBishopB = 0, nbrBishopN = 0, bishopValue = 0;
int resultat, materiel=0; for(j = 0 ; j <= 7 ; j++)
{
for(i = 0 ; i <= 7 ; i++)
{
switch(board.mat[i][j])
{
case 'p':
materiel += 100;
matrice += PawnTable[j + i * 8]; nbrPionB ++;
pionPosB = true; if(!pionPosB_1)
{
if(!pionPosB_2)
{
pionPosB_2 = true; rowB = j;
}
else
{
if (rowB != j)
{
pionPosB_1 = true;
}
}
}
break; case -'p':
materiel -= 100;
matrice -= PawnTable[j + (7 - i) * 8]; nbrPionN ++;
pionPosN = true; if(!pionPosN_1)
{
if(!pionPosN_2)
{
pionPosN_2 = true; rowN = j;
}
else
{
if (rowN != j)
{
pionPosN_1 = true;
}
}
}
break; case 'C':
materiel += 300;

matrice += KnightTable[j + i * 8];
break; case -'C':
materiel -= 300;

matrice -= KnightTable[j + (7 - i) * 8]; break;
case 'f':
materiel += 325;
matrice += BishopTable[j + i * 8]; nbrBishopB ++;
break; case -'f':
materiel -= 325;
matrice -= BishopTable[j + (7 - i) * 8]; nbrBishopN ++;
break; case 't':
materiel += 500;
matrice += RookTable[j + i * 8]; k = 0;
while((k <= 7) && (board.mat[k][j] != 'p'))
{
if(((board.mat[k][j] == 0) || (board.mat[k][j] == 't')) || (board.mat[k][j] < 0))
{
rockB_nbrOpen ++;
}
k++;
}
break; case -'t':
materiel -= 500;
matrice -= RookTable[j + (7 - i) * 8]; k = 7;
while((k >= 0) && (board.mat[k][j] != -'p'))
{
if(((board.mat[k][j] == 0) || (board.mat[k][j] == -'t')) || (board.mat[k][j] < 0))
{
rockN_nbrOpen ++;
}
k --;
}
break; case 'n':
materiel += 1000;
k = 0;
while((k <= 7) && (board.mat[k][j] != 'p'))
{
if(((board.mat[k][j] == 0) || (board.mat[k][j] == 'n')) || (board.mat[k][j] < 0))
{
queenB_nbrOpen ++;
}
k++;
}
break; case -'n':
materiel -= 1000;
k = 7;
while((k >= 0) && (board.mat[k][j] != -'p'))
{
if(((board.mat[k][j] == 0) || (board.mat[k][j] == -'n')) || (board.mat[k][j] < 0))
{
queenN_nbrOpen ++;
}
k --;
}
break; case 'r':
if(nbrPieces(board, true) > 8)
{
matrice += KingO[j + i * 8];
}
if(nbrPieces(board, true) < 7)
{
matrice += KingE[j + i * 8];
}
break; case -'r':
if(nbrPieces(board, true) > 8)
{
matrice -= KingO[j + (7 - i) * 8];
}
if(nbrPieces(board, true) < 7)
{
matrice -= KingE[j + (7 - i) * 8];
}
break;
}
}

if(nbrPionB > 0)
{
doubl = doubl + nbrPionB - 1;
}
if(nbrPionN > 0)
